Package jescript;

Helpers
	// From core_scan.erl -
	// For handling ISO 8859-1 (Latin-1) we use the following type
	// information:
	//
	// Dec      	Octal    	Chars   	Class
	//   0 - 31 	000 - 037	NUL - US	control
	//  32 - 47 	040 - 057	SPC - / 	punctuation
	//  48 - 57 	060 - 071	0 - 9   	digit
	//  58 - 64 	072 - 100	: - @   	punctuation
	//  65 - 90 	101 - 132	A - Z   	uppercase
	//  91 - 96 	133 - 140	[ - `   	punctuation
	//  97 - 122	141 - 172	a - z   	lowercase
	// 123 - 126	173 - 176	{ - ~   	punctuation
	// 127 -    	177      	DEL     	control
	// 128 - 159	200 - 237	        	control
	// 160 - 191	240 - 277	NBSP - ¿	punctuation
	// 192 - 214	300 - 326	À - Ö   	uppercase
	// 215 -    	327      	×       	punctuation
	// 216 - 222	330 - 336	Ø - Þ   	uppercase
	// 223 - 246	337 - 366	ß - ö   	lowercase
	// 247 -    	367      	÷       	punctuation
	// 248 - 255	370 - 377	ø - ÿ   	lowercase

	any = [0..0xffff];
	whitespace = [[0..32]+[127..160]]+;                        // cr, lf, space, tab, control characters

	lowercase = [[248..255] + [[223..246] + ['a'..'z']]];
	uppercase = [[216..222] + [[192..214] + ['A'..'Z']]];
	digit = ['0'..'9'];
	hex = digit | [['a'..'f']+['A'..'F']];
	octal = ['0'..'7'];
	control = [[64..95]+[97..122]];
	alphanum = lowercase | uppercase | digit | ['_'+'@'];
	nonsinglequote = [any - '''];
	nonquote = [any - '"'];
	escapedchar = '\' [any - ['x'+'^']] | '\^' control | '\' octal octal? octal? | '\x' hex hex;
	comment = '%' [any - [10 + 13]]*;
	ignored = whitespace | comment;

Tokens

	// Separators
	lparen = '('; rparen = ')'; lbrace = '{'; rbrace = '}'; lbrack = '['; rbrack = ']';
	dot = '.'; colon = ':'; bar = '|'; barbar = '||'; semi = ';'; comma = ','; question = '?';
	arrow = '->'; pound = '#'; ltlt = '<<'; gtgt = '>>';

	// Operators
	plus = '+'; dash = '-'; star = '*'; slash = '/'; div = 'div'; rem = 'rem';
	or = 'or'; xor = 'xor'; and = 'and'; andalso = 'andalso'; orelse = 'orelse';
	bor = 'bor'; bxor = 'bxor'; bsl = 'bsl'; bsr = 'bsr'; band = 'band'; 
	eq = '='; eqeq = '=='; neq = '/='; lt = '<'; gt = '>'; le = '<='; ge = '>=';
	equiv = '=:='; nequiv = '=/=';
	not = 'not'; bnot = 'bnot'; plusplus = '++'; minusminus = '--'; bang = '!'; larrow = '<-';

	// Keywords
	after = 'after'; begin = 'begin'; case = 'case'; catch = 'catch'; cond = 'cond';
	end = 'end'; fun = 'fun'; if = 'if'; let = 'let'; of = 'of'; query = 'query';
	receive = 'receive'; try = 'try'; when = 'when';
	
	// Attributes
	file = 'file'; module = 'module';
	export = 'export'; import = 'import';
	compile = 'compile'; record = 'record';
	
	// Define attributes will be removed by the preprocessor
	//define_attr = '-' ignored* 'define' ignored* '(' ignored* alphanum+ ignored* ',' nonrparen* (')' ignored* nondot nonrparen*)* ')'+ ignored* '.';

	nil = '[' ignored* ']';
	underscore = '_';    // ("universal" pattern)

	// Numbers -- from core_scan.erl:
	// We can handle simple radix notation:
	//   <digit>#<digits>		- the digits read in that base
	//   <digits>				- the digits in base 10
	//   <digits>.<digits>
	//   <digits>.<digits>E+-<digits>
	integer
		= digit+
		| digit '#' digit+;
	decimal
		= digit+ '.' digit+
		| digit+ '.' digit+ ('e' | 'E') ('+' | '-')? digit+;
	
	// Atoms
	atom
		= lowercase alphanum*
		| ''' nonsinglequote* ('\' ''' nonsinglequote*)* ''';
	
	// Variable
	var
		= '_' alphanum+
		| uppercase alphanum*;

	// Strings
	char = '$' (escapedchar | any);
	string = '"' nonquote* ('\"' nonquote*)* '"';	

	// Whitespace/comments
	whitespace = whitespace;
	comment = comment;

Ignored Tokens
	whitespace,
	comment;

Productions

	// -------------------------------------------------------
	// Top-level module definition
	// -------------------------------------------------------
	module
		= file_attrs* module_attr header_attrs* prog_forms?;
	
	// -------------------------------------------------------
	// Module attributes
	// -------------------------------------------------------
	file_attrs
		= dash file lparen string comma integer rparen dot;
	module_attr = dash T.module lparen atom rparen dot;
	header_attrs
		= {export} dash export lparen lbrack fun_names rbrack rparen dot
		| {import} dash import lparen [module]:atom comma lbrack fun_names rbrack rparen dot
		| {compile} dash compile lparen header_attr_term rparen dot
		| {anywhere} anywhere_attrs
		| {other} dash atom lparen header_attr_term rparen dot;
	anywhere_attrs
		= {file} file_attrs
		| {record_decl} dash record lparen [type]:atom comma lbrace record_field_decls? rbrace rparen dot;
		// Define attributes are removed by the preprocessor
	header_attr_term
		= {literal} literal
		| {fun} atom slash integer
		| {parens} lparen header_attr_term rparen
		| {tuple} lbrace header_attr_term_list? rbrace
		| {list} lbrack header_attr_term_list header_attr_term_list_tail? rbrack
		| {nil} nil;
	header_attr_term_list
		= {one} header_attr_term
		| {many} header_attr_term_list comma header_attr_term;
	header_attr_term_list_tail
		= bar header_attr_term;
	fun_names
		= {one} atom slash integer
		| {many} fun_names comma atom slash integer;
		
	// Records
	record_field_decls
		= {one} [name]:atom record_field_value?
		| {many} record_field_decls comma [name]:atom record_field_value?;
	record_field_value
		= eq expr;

	// -------------------------------------------------------
	// Program body
	// -------------------------------------------------------
	prog_forms
		= {one} fun_decl
		| {many} prog_forms fun_decl
		| {att} prog_forms anywhere_attrs;
	
	// Functions
	fun_decl
		= function_clauses dot;
	function_clauses
		= {one} [fun]:atom fun_clause
		| {many} function_clauses semi [fun]:atom fun_clause;
	fun_clause
		= lparen patterns? rparen clause_guard? arrow exprs;
	patterns
		= {one} pattern
		| {many} patterns comma pattern;
	pattern
		= {literal} literal
		| {var} var
		| {universal} underscore
		| {tuple} lbrace patterns? rbrace
		| {record} pound [type]:atom lbrace record_field_patterns? rbrace
		| {list} lbrack patterns list_pattern_tail? rbrack
		| {nil} nil
		| {parens} lparen pattern rparen;
	record_field_patterns
		= {one} [name]:atom eq pattern
		| {many} record_field_patterns comma [name]:atom eq pattern;
	list_pattern_tail
		= bar pattern;
	clause_guard
		= when guard_exprs;

	// -------------------------------------------------------
	// Guards
	// -------------------------------------------------------
	guard_exprs
		= {one} guard_expr
		| {many} guard_exprs comma guard_expr;
	guard_expr
		= guard_compare_expr;
	guard_compare_expr
		= {lt} [left]:guard_addition_shift_expr [op]:relational_op [right]:guard_addition_shift_expr
		| {le} [left]:guard_addition_shift_expr [op]:equality_op [right]:guard_addition_shift_expr
		| {simple} guard_addition_shift_expr;
	guard_addition_shift_expr
		= {plus} [left]:guard_addition_shift_expr [op]:addition_op [right]:guard_times_expr
		| {minus} [left]:guard_addition_shift_expr [op]:shift_op [right]:guard_times_expr
		| {simple} guard_times_expr;
	guard_times_expr
		= {times} [left]:guard_times_expr [op]:mult_op [right]:guard_preop_expr
		| {simple} guard_preop_expr;
	guard_preop_expr
		= {pos} [op]:pre_op [expr]:guard_apply_expr
		| {simple} guard_apply_expr;
	guard_apply_expr
		= {fun} [fun]:atom lparen [args]:guard_exprs? rparen
		| {record} guard_record_expr
		| {simple} guard_primary_expr;
	guard_record_expr
		= guard_primary_expr? pound [record]:atom dot [field]:atom;
	guard_primary_expr
		= {literal} literal
		| {var} var
		| {nil} nil
		| {list} lbrack guard_exprs guard_list_skeleton_tail? rbrack
		| {record} lbrace guard_exprs? rbrace
		| {parens} lparen guard_expr rparen;
	guard_list_skeleton_tail
		= bar guard_expr;

	// -------------------------------------------------------
	// Expressions
	// -------------------------------------------------------
	exprs
		= {one} expr
		| {many} exprs comma expr;
	expr 
		= match_expr;
	match_expr
		= send_expr eq match_expr
		| {simple} send_expr;
	send_expr
		= [left]:compare_expr bang [right]:send_expr
		| {simple} compare_expr;
	compare_expr
		= {lt} [left]:list_conc_expr [op]:relational_op [right]:list_conc_expr
		| {equiv} [left]:list_conc_expr [op]:equality_op [right]:list_conc_expr
		| {simple} list_conc_expr;
	list_conc_expr
		= [left]:addition_shift_expr [op]:list_conc_op [right]:list_conc_expr
		| {simple} addition_shift_expr;
	addition_shift_expr
		= {plus} [left]:addition_shift_expr [op]:addition_op [right]:times_expr
		| {minus} [left]:addition_shift_expr [op]:shift_op [right]:times_expr
		| {simple} times_expr;
	times_expr
		= {times} [left]:times_expr [op]:mult_op [right]:preop_expr
		| {simple} preop_expr;
	preop_expr
		= {pos} [op]:pre_op [expr]:apply_expr
		| {simple} record_expr;
	record_expr
		= {field} record_expr? pound [type]:atom dot [name]:atom
		| {update} record_expr? pound [type]:atom lbrace record_field_updates? rbrace
		| {simple} apply_expr; 
	apply_expr
		= {local} [fun]:primary_expr lparen [args]:exprs? rparen
		| {module} [module]:primary_expr colon [fun]:primary_expr lparen [args]:exprs? rparen
		| {simple} primary_expr;
	primary_expr
		= {var} var
		| {literal} literal
		| {tuple} lbrace exprs? rbrace
		| {list} list
		| {comprehension} lbrack expr barbar comprehension_exprs rbrack
		| {block} begin exprs end
		| {if} if if_clauses end
		| {case} case expr of case_clauses end
		| {receive} receive_expr
		| {fun} fun_expr
		| {paren} lparen expr rparen
		| {universal_pattern} underscore;
	fun_expr
		= {local} [fun_keyword]:fun [fun]:atom slash [arity]:integer
		| {module} [fun_keyword]:fun [module]:atom colon [fun]:atom slash [arity]:integer
		| {anon} fun fun_clauses end;
	receive_expr
		= receive case_clauses end
		| {after} receive case_clauses? after expr arrow exprs end;
	
	// Expression helpers
	literal
		= {integer} integer
		| {decimal} decimal
		| {char} char
		| {string} strings
		| {atom} atom
		| {attribute} attribute;
	attribute
		= {file} file | {module} T.module
		| {export} export | {import} import
		| {compile} compile | {record} record;
	relational_op = {lt} lt | {gt} gt | {le} le | {ge} ge;
	equality_op = {equiv} equiv | {nequiv} nequiv | {eq} eqeq | {neq} neq;
	list_conc_op = {conc} plusplus | {remove} minusminus;
	addition_op = {plus} plus | {minus} dash | {bor} bor | {bxor} bxor;
	shift_op = {bsl} bsl | {bsr} bsr;
	mult_op = {times} star | {divide} slash | {div} div | {rem} rem | {band} band;
	pre_op = {pos} plus | {neg} dash | {bnot} bnot | {not} not;
	record_field_updates
		= {one} [name]:atom eq expr
		| {many} record_field_updates comma [name]:atom eq expr;
	strings
		= {one} string
		| {many} strings string;
	list
		= lbrack list_terms list_tail? rbrack
		| {nil} nil;
	list_terms
		= {one} expr
		| {many} list_terms comma expr;
	list_tail
		= bar expr;
	comprehension_exprs
		= {one} comprehension_expr
		| {many} comprehension_exprs comma comprehension_expr;
	comprehension_expr
		= {generator} [pattern]:expr larrow expr
		| {filter} expr;
	if_clauses
		= {one} guard_exprs arrow exprs
		| {many} if_clauses semi guard_exprs arrow exprs;
	case_clauses
		= {one} pattern clause_guard? arrow exprs
		| {many} case_clauses semi pattern clause_guard? arrow exprs;
	fun_clauses
		= {one} fun_clause
		| {many} fun_clauses semi fun_clause;